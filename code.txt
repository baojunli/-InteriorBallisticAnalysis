M99重型狙击步枪配用12.7mm穿甲燃烧弹内弹道过程(貌似参数有些问题)
 #include<iostream>
#include<fstream>
#include<math.h>
#include<vector>
using namespace std;
struct Point
{
 double t;        //时间
 double p;        //压力
 double l;        //行程
 double v;        //速度
 double Z;        //已燃相对厚度
 double K;        //燃去百分比
};
//微分方程原型
double FZt(double Z,double Zk,double c,double B,double p,double n)
{
 if(Z<Zk)
  return (sqrt(c/(2*B))*pow(p,n));
 if(Z>=Zk)
  return 0;
}
double FLt(double v)
{
 return v;
}
double FVt(double c,double p)
{
 return (c*p/2);
}
double FK(double Z,double Zk,double cai,double r,double u,double cais,double rs)
{
 if(Z<1)
  return cai*Z*(1+r*Z+u*Z*Z);
 if(Z>=1&&Z<Zk)
  return cais*Z*(1+rs*Z);
 if(Z>=Zk)
  return 1;
}
double FP(double lk,double l,double K,double v)
{
 return (K-v*v)/(lk+l);
}
double Flk(double de,double Pp,double a,double K)
{
 return 1-de/Pp-(a-1/Pp)*de*K;
}

//四阶龙格库塔方程
Point Runge_Kutta(Point pt,double h,double Zk,double c,double B,double n,double cai,double r,double u,double cais,double rs,double de,double Pp,double a)
{
 double kz1=h*FZt(pt.Z,Zk,c,B,pt.p,n);
 double kl1=h*FLt(pt.v);
 double kv1=h*FVt(c,pt.p);
 double K2=FK(pt.Z+kz1/2,Zk,cai,r,u,cais,rs);
 double lk2=Flk(de,Pp,a,K2);
 double p2=FP(lk2,pt.l+kl1/2,K2,pt.v+kv1/2);
 double kz2=h*FZt(pt.Z+kz1/2,Zk,c,B,p2,n);
 double kl2=h*FLt(pt.v+kv1/2);
 double kv2=h*FVt(c,p2);
 double K3=FK(pt.Z+kz2/2,Zk,cai,r,u,cais,rs);
 double lk3=Flk(de,Pp,a,K3);
 double p3=FP(lk3,pt.l+kl2/2,K3,pt.v+kv2/2);
 double kz3=h*FZt(pt.Z+kz2/2,Zk,c,B,p3,n);
 double kl3=h*FLt(pt.v+kv2/2);
 double kv3=h*FVt(c,p3);
 double K4=FK(pt.Z+K3,Zk,cai,r,u,cais,rs);
 double lk4=Flk(de,Pp,a,K4);
 double p4=FP(lk4,pt.l+kl3,K4,pt.v+kv3);
 double kz4=h*FZt(pt.Z+kz3,Zk,c,B,p4,n);
 double kl4=h*FLt(pt.v+kv3);
 double kv4=h*FVt(c,p4);
 Point next;
 next.Z=pt.Z+(kz1+2*kz2+2*kz3+kz4)/6;
 next.l=pt.l+(kl1+2*kl2+2*kl3+kl4)/6;
 next.v=pt.v+(kv1+2*kv2+2*kv3+kv4)/6;
 next.K=FK(next.Z,Zk,cai,r,u,cais,rs);
 double lk0=Flk(de,Pp,a,next.K);
 next.p=FP(lk0,next.l,next.K,next.v);
 next.t=pt.t+h;
 return next;
}
//还原相对数值
Point Return(Point pt,double l0,double Vj,double f,double de)
{
 Point red;
 red.l=pt.l*l0;
 red.t=pt.t*l0/Vj;
 red.p=pt.p*f*de;
 red.v=pt.v*Vj;
 red.K=pt.K;
 red.Z=pt.Z;
 return red;
}
int main()
{
 //输入已知数据
 //枪膛构造及弹丸诸元
 double S=1.3E-4;   //枪膛截面积 m2
 double V0=20.7E-6; //药室容积 m3
 double lg=0.654;  //弹丸行程
 double m=48.2E-3; //弹丸质量 kg
 //装药条件
 double f=980;       //火药力 KJ/Kg
 double a=9.2E-4;    //余容
 double w=17;       //装药量 g
 double Pp=1600;    //火药密度 Kg/m3
 double c=0.22;     //火药热力系数
 double u1=6.85E-8; //燃速系数
 double n=0.85;     //压力指数
 double e1=2E-4;    //弧厚 m
 double cai=0.8235;  //形状特征量
 double r=0.13207;
 double u=-0.05160;
 double p=1.1518E-4;
 //初始条件
 double p0=40;     //MPa
 //次要功计算参数
 double K1=1.10;
 double b=0.2520;
 //计算步长
 double h=0.01;
 //常量计算
 double Zk=(p+e1)/e1;
 double fai=K1+b*w/(m*1000);   //次要功系数
 double de=w/(V0*1E6);        //装填密度
 double l0=V0/S;             //自由容积缩径长 m
 double Vj=sqrt((2*f*w)/(c*fai*m));  //理论最大速度 m/s
 double B=((S*S*e1*e1)/(f*w*fai*m*u1*u1))*pow(f*de,2*(1-n));
 double Ks=cai*(1+r+u);
 double cais=(1-Ks*Zk*Zk)/(Zk-Zk*Zk);
 double rs=Ks/cais-1;
 
 //初值计算
 Point temp;
 vector<Point> pt;
 double tb=0;
 double lb=0;
 double vb=0;
 double pb=p0/(f*de);
 double K=(1/de-1/Pp)/(f/p0+a-1/Pp);
 double c0=sqrt(1+4*r*K/cai);
 double Z=(c0-1)/(2*r);
 temp.t=tb;
 temp.l=lb;
 temp.v=vb;
 temp.p=pb;
 temp.Z=Z;
 temp.K=K;
 pt.push_back(temp);
 double end=lg/l0;
 vector<Point>::iterator iter;
 iter=pt.end()-1;
 while((*iter).l<=end)
 {
  temp=Runge_Kutta(*iter,h,Zk,c,B,n,cai,r,u,cais,rs,de,Pp,a);
  pt.push_back(temp);
  iter=pt.end()-1;
 }
 for(iter=pt.begin();iter!=pt.end();iter++)
 {
  *iter=Return(*iter,l0,Vj,f,de);
 }
 ofstream outfile("solution.xls",ios::out);
 outfile<<"t(s)"<<" "<<"l(m)"<<" "<<"v(m/s)"<<" "<<"p(MPa)"<<" "<<"K"<<" "<<"Z"<<endl;
 for(iter=pt.begin();iter!=pt.end();iter++)
 {
  outfile<<(*iter).t<<" "<<(*iter).l<<" "<<(*iter).v<<" "<<(*iter).p<<" "<<(*iter).K<<" "<<(*iter).Z<<endl;
 }
 cout<<"内弹道求解完毕！"<<endl;
}
